#!/bin/env python3

# -*- coding: UTF-8 -*-

#  Copyright (c) 2016 Jakub Filipowicz <jakubf@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

import os
import sys
import datetime
import argparse
import numpy as np

matplotlib = 1
try:
    import matplotlib.pyplot as plt
except:
    matplotlib = 0
    print("* WARNING: can't use matplotlib, graphical statistics are unavailable")

# ------------------------------------------------------------------------
# oh for fuck's sake...
def unitize(i, fraclen=3, base=1000):
    up = [
        [ 5, "P" ],
        [ 4, "T" ],
        [ 3, "G" ],
        [ 2, "M" ],
        [ 1, "K" ],
        [ 0, "" ],
        [ -1, "m" ],
        [ -2, "u" ],
        [ -3, "n" ],
        [ -4, "p" ]
    ]

    frm = "%%.%if " % fraclen
    suffix = ""
    if base == 1024:
        suffix = "i"

    for u in up:
        if i >= base**u[0]:
            return (frm + u[1] + suffix) % (i / base**u[0])
    return str(i)

# ------------------------------------------------------------------------
def parity9(x):
    x ^= x >> 8
    x ^= x >> 4
    x ^= x >> 2
    x ^= x >> 1
    return x&1

# ------------------------------------------------------------------------
class Track:
    HIST_BINS = 1000

    # --------------------------------------------------------------------
    def __init__(self, bits, num):
        self.num = num

        print("(edges...", end="", flush=True)
        # offsets in a bitstream where signal switches polarity
        self.pulse_offsets = np.where(bits[:-1] != bits[1:])[0]
        if len(self.pulse_offsets) <= 0:
            print("")
            raise ValueError("No signal edges found on track %s" % num)

        print("\b\b\b, lengths...", end="", flush=True)
        # pulse lengths (to the next polarity switch)
        self.pulse_lengths = self.pulse_offsets[1:] - self.pulse_offsets[:-1]
        if len(self.pulse_lengths) <= 0:
            print("")
            raise ValueError("No pulse lengths found on track %s" % num)

        self.hist, self.hedges = np.histogram(self.pulse_lengths, bins=np.arange(0, Track.HIST_BINS, 1))
        self.bpl = self.hedges[np.where(self.hist == self.hist.max())[0]][0]
        print("\b\b\b, histogram). Most frequent pulse length is %i samples" % self.bpl)
        if self.bpl <= 0:
            raise ValueError("Cannot determine base pulse length for track %s" % num)
       
    # --------------------------------------------------------------------
    def print_stats(self):
        print("* Track %i statistics:" % self.num)
        screen_width = int(os.popen('stty size', 'r').read().split()[1])
        print("  * Most frequent pulse: %i samples" % self.bpl)
        print("  * Pulse length histogram (pulse len : scaled pulse count):")
        for i, e in enumerate(self.hedges):
            if (self.hist[i-1]) > 0:
                print("    %3i : %s" % (e, "#" * np.ceil((screen_width-14) * self.hist[i] / self.hist.max())))
    

# ------------------------------------------------------------------------
class Tape:

    track_names = [ '0', '1', '2', '3', '4', '5', '6', '7', 'P' ]

    # --------------------------------------------------------------------
    def __init__(self, filename, channels, downsample=1, bpl=0):

        print("* Using channel:track mapping:", end="")
        for t, c in enumerate(reversed(channels)):
            print(" %i:%s" % (c, self.track_names[t]), end="")
            if t != 8:
                print(",", end="")
        print("")

        print("* Opening tape image: %s with %i data channels..." % (filename, len(channels)))
        samples = np.fromfile(filename, dtype=np.uint16)
        print("* Input data: %sB, %ssamples" % (unitize(samples.nbytes, base=1024), unitize(len(samples))))
        if downsample > 1:
            print("* Downsampling by %i to  %ssamples" % (downsample, unitize(len(samples)/downsample)))
            samples = np.array(samples[0::downsample], dtype=np.uint16)
        if len(samples) == 0:
            raise ValueError("No samples to process")

        mem = self.mem_estimate(len(samples), len(channels))
        print("* Estimated peak memory usage: %sB" % unitize(mem, base=1024))

        self.tracks = []
        self.bpl = 0
        for i, c in enumerate(channels):
            print("* Slicing channel %i into track %s: " % (c, self.track_names[i]), end="", flush=True)
            data = np.bitwise_and(samples, 1<<c)
            t = Track(data, i)
            self.tracks.append(t)
            self.bpl += t.bpl

        if bpl > 0:
            self.bpl = bpl
            print("* Using user-provided Base Pulse Length of %i samples" % self.bpl)
        else:
            self.bpl = int(np.round(self.bpl / len(channels)))
            print("* Using most frequent pulse length of %i samples as the Base Pulse Length" % self.bpl)

        del samples

        print("* Tape is now ready to roll!")
        
    # --------------------------------------------------------------------
    def mem_estimate(self, sample_count, track_count):
        TRACK_FILL = 0.22
        mem_samples = sample_count * 4
        mem_tracks = track_count * sample_count * (4+4) * TRACK_FILL

        return mem_samples + mem_tracks

    # --------------------------------------------------------------------
    def print_stats(self):
        for t in self.tracks:
            t.print_stats()

    # --------------------------------------------------------------------
    def graph_stats(self):
        minlen = 0
        maxlen = np.max([t.pulse_lengths.max() for t in self.tracks])
        plt.hist([t.pulse_lengths for t in self.tracks], np.arange(minlen, maxlen, 1), orientation='vertical', histtype='stepfilled', log=False, stacked=True, edgecolor = "none")
        plt.grid(True)
        plt.xticks(np.arange(minlen, maxlen, int((maxlen - minlen) / 30)))
        plt.title("Pulse lengths histogram (all tracks)")
        plt.ylabel("Count")
        plt.xlabel("Pulse width [samples]")
        plt.show()

# --------------------------------------------------------------------
class ScannerPE:

    # --------------------------------------------------------------------
    def __init__(self, tape):
        self.tape = tape
        self.track_preambles = []
        self.preambles = None
        self.p_delta = int(np.round(args.pulsemargin * tape.bpl))
        self.pshort_min = tape.bpl - self.p_delta
        self.pshort_max = tape.bpl + self.p_delta
        self.plong_min = 2 * tape.bpl - self.p_delta
        self.plong_max = 2 * tape.bpl + self.p_delta
        self.row = np.zeros(16, dtype=np.int64)
        self.blocks = []
        self.max_skew = args.skew * self.tape.bpl
        print("* PE scaner initialized with: bpl=%i, margin=%f (%i), short=[%i..%i], long=[%i..%i], skew=%f (%i)" % (tape.bpl, args.pulsemargin, self.p_delta, self.pshort_min, self.pshort_max, self.plong_min, self.plong_max, args.skew, self.max_skew))

    # --------------------------------------------------------------------
    def track_scan(self, track):
        print("* Searching for PE preambles on track %s:" % (Tape.track_names[track.num]), end="", flush=True)

        preambles = []
        pc = 0
        for i, p in enumerate(track.pulse_lengths):
            # found correct pulse width
            if self.pshort_min <= p <= self.pshort_max:
                # this is the first pulse in a burst
                if pc == 0:
                    # store burst start
                    start = i
                pc += 1
            # incorrect pulse width
            else:
                # TODO: allow for missing pulses

                # got something this far
                # (25 x "0" = 50 pulses = minimum specified by the protocol)
                if pc > 50 and self.plong_min <= p <= self.plong_max:
                    preambles.append(start)
                    pc = 0
                    print("\r* Searchin for PE preambles on track %s: %i%% (%i preambles found)" % (Tape.track_names[track.num], 100*i/len(track.pulse_lengths), len(preambles)), end="", flush=True)
                pc = 0
                start = 0
    
        print("\r* Found %i PE preambles on track %s                                                      " % (len(preambles), Tape.track_names[track.num]))
        return preambles

    # --------------------------------------------------------------------
    def skew_check(self, pulse_ids):
        # find pulse offsets for all pulse ids on all tracks
        pulse_offsets = np.array([self.tape.tracks[x].pulse_offsets[pulse_ids[x]] for x in np.arange(len(pulse_ids))])
        diff = pulse_offsets.max() - pulse_offsets.min()
        if diff > self.max_skew:
            return False, diff
        return True, diff

    # --------------------------------------------------------------------
    def scan(self):
        print("* Searching for PE preambles")
        for i, track in enumerate(self.tape.tracks):
            preambles = self.track_scan(track)
            if not preambles:
                raise ValueError("No PE preambles found on track %s" % (Tape.track_names[track.num]))
            self.track_preambles.append(preambles)

        print("* Checking PE preambles align...", end="", flush=True)
        self.preambles = np.array(self.track_preambles).T
        for i, p in enumerate(self.preambles):
            skew_ok, diff = self.skew_check(p)
            if not skew_ok:
                print("")
                raise ValueError("Preamble %i has a skew of %i, while max allowed is %i" % (i, diff, max_skew))

        print("\b\b\b: OK!")
        return True

    # --------------------------------------------------------------------
    def row_get(self, pidxs):
        data = 0
        nextp = []
        # get all bits in a row
        # pidxs is an array of pulse indexes for each track
        # for each track...
        for t, pn in enumerate(pidxs):
            # put the bit in
            data |= self.row[t] << t
            # ...get the pulse len
            plen = self.tape.tracks[t].pulse_lengths[pn]
            # if it's a short pulse, skip it to align to the next bit pulse
            # this also means next bit has the same value as current
            if self.pshort_min <= plen <= self.pshort_max:
                nextp.append(pn + 2)
            # if this is a long pulse, that means polarity changes
            # and that means next bit value changes (flip self.row)
            elif self.plong_min <= plen <= self.plong_max:
                self.row[t] ^= 1
                nextp.append(pn + 1)
            else:
                raise ValueError("Incorrect pulse length")
        return data, nextp

    # --------------------------------------------------------------------
    def block_read(self, p):
        # We know first row is all "0" in the beginning (start of preamble)
        self.row.fill(0)
        nextp = p

        # block regions
        R_PREAMBLE = 1
        R_DATA = 2
        R_FAILED = 666
        R_OK = 777

        region = R_PREAMBLE
        p0_count = 0
        block = []
        maybe_postamble = 0

        # analyze each row of a block
        # nextp is an array of pulse indices for the next row
        # row is the data
        while region not in [ R_FAILED, R_OK ]:

            data, nextp = self.row_get(nextp)

            if region == R_PREAMBLE:
                if data == 0:
                    p0_count += 1
                elif data == 0b111111111:
                    if p0_count >= 25:
                        region = R_DATA
                    else:
                        region = R_FAILED

            elif region == R_DATA:
                block.append(data)
                if data == 0b111111111: # possible start of postamble
                    maybe_postamble = 1
                    p0_count = 0
                elif data == 0 and maybe_postamble:
                    p0_count += 1
                    if p0_count >= 25:
                        region = R_OK
                else:
                    maybe_postamble = 0

        if region == R_FAILED:
            return None
        else:
            return block[:-(p0_count+1)]

    # --------------------------------------------------------------------
    def analyze(self):
        # p is an array of n pulse indices in tape.track[0...n-1].pulse_lengths
        # each p denotes start of a PE block
        # iterate over all block preambles
        print("* Reading PE blocks:", end="", flush=True)
        for i, p in enumerate(self.preambles):
            try:
                block = self.block_read(p)
                self.blocks.append(block)
            except Exception as e:
                print("\n* WARNING: could not read block %i (%s)" % (i, e))
            print("\r* Reading PE blocks: %i%% (%i blocks)" % (i*100 / len(self.preambles), len(self.blocks)), end="", flush=True)
        print("\r* Got %i PE blocks                    " % (len(self.blocks)))


# ------------------------------------------------------------------------
def eerr(s):
    print("* FATAL: %s" % s)
    sys.exit(1)

# ------------------------------------------------------------------------
# --- MAIN ---------------------------------------------------------------
# ------------------------------------------------------------------------

# parse and prepare arguments

parser = argparse.ArgumentParser(description='Virtual 9-Track Tape Drive')
parser.add_argument('-i', '--input', help="Input tape image", required=True)
parser.add_argument('-o', '--output', help="Output file name or prefix", required=False)
parser.add_argument('-O', '--otype', help="Output type", choices=['blocks', 'files', 'emimg', 'print'], required=False)
parser.add_argument('-c', '--chlist', help="Input channel list specified as: p,7,6,5,4,3,2,1,0 (p=parity track, 0=LSB track). Default mapping is: 8,7,6,5,4,3,2,1,0", default="8,7,6,5,4,3,2,1,0", required=False)
parser.add_argument('-d', '--downsample', help="Downsample input data by n > 1", type=int, default=0, required=False)
parser.add_argument('-p', '--pulselen', help="Base pulse length (guessed if none specified)", type=int, required=False, default=0)
parser.add_argument('-m', '--pulsemargin', help="Max allowed base pulse margin (0.0 - 0.5)", type=float, required=False, default=0.3)
parser.add_argument('-s', '--skew', help="Max allowed track skew (0.0 - 0.5)", type=float, required=False, default=0.1)
parser.add_argument('-S', '--stats', help="Print track stats and exit", action='store_true', required=False)
parser.add_argument('-G', '--gstats', help="Draw track stats and exit", action='store_true', required=False)
args = parser.parse_args()

chlist = [int(i) for i in args.chlist.split(',')]
if len(chlist) != 9:
    eerr("Need 9 channels in -c chlist")
if np.min(chlist) < 0 or np.max(chlist) > 15:
    eerr("Track indices must be between 0 and 15")
    sys.exit(1)
if not 0.0 < args.skew < 0.5:
    eerr("Track skew must be between 0.0 and 0.5")
if not 0.0 < args.pulsemargin < 0.5:
    eerr("Pulse length margin must be between 0.0 and 0.5")
if args.downsample != 0 and args.downsample <= 1:
    eerr("Downsample must be an integer number > 1")
if args.pulselen < 0:
    eerr("Base pulse length must be an integer number > 1")

# start tape analysis

t_start = datetime.datetime.now()

try:
    tape = Tape(args.input, chlist, downsample=args.downsample, bpl=args.pulselen)
except Exception as e:
    eerr("Tape open failed (%s)" % e)

# print stats and exit

if args.stats:
    tape.print_stats()
    exit(0)
if args.gstats:
    if matplotlib == 0:
        eerr("Matplotlib unavailable, can't graph")
    tape.graph_stats()
    exit(0)

# PE scan
try:
    pe = ScannerPE(tape)
    pe.scan()
    pe.analyze()
except Exception as e:
    eerr("PE analysis failed (%s)" % e)

t_end = datetime.datetime.now()
print("* Total analysis time: %s" % (t_end-t_start))

# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
